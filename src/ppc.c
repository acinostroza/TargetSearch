#include <R.h>
#include <Rdefines.h>

#include "ppc.h"
#include "ncdf.h"

/*  Main Program:
 *  Args:
 *    - NCDF: A netcdf object. A list generated by the function .open.ncdf
 *         with these fields
 *         + point_count
 *         + scan_index
 *         + intensity_values
 *         + mass_values
 *         + scan_acquisition_time
 *    - Window: An integer value. RT window (in scans) for peak detection
 *    - MinInt: Intensity thresold
 *    - IntMatrix: An integer matrix. This is a matrix generated by a previous
 *         call to ncdfToMatrix.
 *  Details:
 *    One of the parameters NCDF or IntMatrix can be NULL. NCDF takes precedence.
 *    IntMatrix is the matrix that would be generated if the object NCDF is passed.
 *    'IntMatrix' is used in case the ncdf is in the new format.
 */

SEXP ppc(SEXP NCDF, SEXP Window, SEXP MassLimits, SEXP MinInt, SEXP IntMatrix)
{
	ncdf_t *nc = !isNull(NCDF) ? new_ncdf(NCDF) : NULL;
	matrix_t *mat = !isNull(NCDF) ? get_intensity_mat(nc) : from_matrix(IntMatrix);

	int min, max;
	int nscans = nc != NULL ? nc->nscans : mat->nr;

	if(!isNull(MassLimits)) {
		int *tmp = INTEGER(AS_INTEGER(MassLimits));
		min = tmp[0];
		max = tmp[1];
	} else {
		min = mat->mzmin;
		max = mat->mzmax;
	}

	int win     = INTEGER_VALUE(Window);
	int min_int = INTEGER_VALUE(MinInt);

	/* Rows = time, columns = m/z */
	int N = mat->nc;
	SEXP MaxIntMatrix = PROTECT(allocMatrix(INTSXP, nscans, N));
	int * maxm = INTEGER_POINTER(MaxIntMatrix);
	int * ans  = Calloc(nscans, int);

	/* Looks for peaks for every mass (column) */
	for(int mz = min, i = 0; i < N; i++, mz++) {
		if(mz < mat->mzmin || mz > mat->mzmax)
			continue;
		int *x = mat->x + (mz - mat->mzmin) * mat->nr;
		peaks(x, win, nscans, ans);
		/* assign maximum values to matrix */
		for(int j = 0; j < nscans; j++) {
			maxm[j + i*nscans] =
				(ans[j] == 1) && (x[j] >= min_int) ? x[j] : 0;
			ans[j] = 0;
		}
	}
	Free(ans);
	Free(nc);
	free_matrix(mat);
	UNPROTECT(1);
	return MaxIntMatrix;
}

/* This function implements PPC algorithm
 * Arguments: x - Intensity vector
 *            ispan - Window
 *            n - length of x
 *            ans - output: 1 if it is a peak, 0 if not
 */
int peaks(int *x, int ispan, int n, int *ans)
{
        int i, j;

        for(i = 0; i < ispan; i++)
                ans[i] = 0;

        for(i = n-ispan; i < n; i++)
                ans[i] = 0;

        i = ispan;

        while (i < n-ispan) {
                ans[i] = 1;
                j = i-ispan;
                while( ans[i] == 1 && j <= i+ispan) {
                        if(x[j] > x[i])
                                ans[i] = 0;
                        j++;
                        if(j == i)
                                j++;

                }
                if(ans[i] == 0)
                        i++;
                if(ans[i] == 1)
                        i += ispan-1;
        }

        return 1;
}
